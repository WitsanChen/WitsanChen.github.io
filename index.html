<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity=sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU= rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-big-counter.css rel=stylesheet><script crossorigin=anonymous integrity=sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0= src=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js></script><script class=next-config data-name=main type=application/json>{"hostname":"witsanchen.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src=/js/config.js></script><meta content="Live, Work, Sports" name=description><meta content=website property=og:type><meta content="More haste, less speed." property=og:title><meta content=https://witsanchen.github.io/index.html property=og:url><meta content="More haste, less speed." property=og:site_name><meta content="Live, Work, Sports" property=og:description><meta content=zh_CN property=og:locale><meta content="Chen Chao" property=article:author><meta content=summary name=twitter:card><link href=https://witsanchen.github.io/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>More haste, less speed.</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>More haste, less speed.</h1> <i class=logo-line></i> </a></div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>2</span></a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>1</span></a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>2</span></a><li class="menu-item menu-item-schedule"><a href=/schedule/ rel=section><i class="fa fa-calendar fa-fw"></i>日程表</a></ul></nav></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt="Chen Chao" class=site-author-image itemprop=image src=/images/myphoto.png><p class=site-author-name itemprop=name>Chen Chao<div class=site-description itemprop=description>Live, Work, Sports</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>2</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><span class=site-state-item-count>1</span><span class=site-state-item-name>分类</span></div><div class="site-state-item site-state-tags"><span class=site-state-item-count>2</span><span class=site-state-item-name>标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://witsanchen.github.io/2023/02/23/daemon/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/myphoto.png itemprop=image> <meta content="Chen Chao" itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="More haste, less speed." itemprop=name> <meta content="Live, Work, Sports" itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | More haste, less speed." itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2023/02/23/daemon/ itemprop=url>daemon</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-02-23 18:36:17 / 修改时间：18:38:46" datetime=2023-02-23T18:36:17+08:00>2023-02-23</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/WebRTC/ itemprop=url rel=index><span itemprop=name>WebRTC</span></a> </span> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>3.6k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>13 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=daemon><a class=headerlink href=#daemon title=daemon></a>daemon</h1><p>daemon - 编写与打包系统守护进程<h1 id=描述><a class=headerlink href=#描述 title=描述></a>描述</h1><p>“守护进程” 的意思是在后台运行的服务进程， 常用于监督系统的运行或者提供某种功能。 在传统的 <code>SysV Unix</code> 系统上， 多个守护进程必须严格按照特定的顺序依次启动。 在” 新型” 的 <code>systemd(1)</code> 系统上， 守护进程的启动顺序非常简单且非常强大。 本手册同时解说了上述两种不同的启动方案， 并特别推荐了应该包含在 <code>systemd</code> 系统中的守护进程。<h2 id=传统的SysV守护进程><a class=headerlink href=#传统的SysV守护进程 title=传统的SysV守护进程></a>传统的 <code>SysV</code> 守护进程</h2><p>传统的 <code>SysV</code> 守护进程在启动的时候， 应该在初始化阶段执行下面的步骤：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line>1. 关闭除 STDIN STDOUT STDERR 之外的所有文件描述符</span><br><span class=line></span><br><span class=line>2. 重置所有信号处理器</span><br><span class=line></span><br><span class=line>3. 重置所有信号掩码</span><br><span class=line></span><br><span class=line>4. 清理环境变量(重置一部分，移除一部分)</span><br><span class=line></span><br><span class=line>5. 调用 fork() 创建一个后台进程</span><br><span class=line></span><br><span class=line>6. 在子进程中调用 setsid() 从终端脱离并创建一个独立的会话</span><br><span class=line></span><br><span class=line>7. 在子进程中再一次调用 fork() 以确保守护进程永远无法获取任何终端。</span><br><span class=line></span><br><span class=line>8. 第一个子进程主动退出， 只有第二个子进程(实际的守护进程)保持运行， 并且以 init(PID=1) 为父进程。</span><br><span class=line></span><br><span class=line>9. 守护进程(第二个子进程)将 STDIN STDOUT STDERR 连接到 /dev/null 虚拟设备</span><br><span class=line></span><br><span class=line>10. 守护进程将 umask 设为 0</span><br><span class=line></span><br><span class=line>11. 守护进程将当前目录切换到根目录(/)</span><br><span class=line></span><br><span class=line>12. 守护进程将自身的PID记录到例如 /run/foobar.pid 这样的文件中</span><br><span class=line></span><br><span class=line>13. 守护进程丢弃自己不需要的权限(如果可以)</span><br><span class=line></span><br><span class=line>14. 守护进程通知最初的父进程：初始化工作已完成</span><br><span class=line></span><br><span class=line>15. 最初的父进程自身退出</span><br></pre></table></figure><p>注意，这些步骤对于下文讲述的新型守护进程是不需要的， 除非为了刻意兼容传统的 <code>SysV系统</code>。<h2 id=新型守护进程><a class=headerlink href=#新型守护进程 title=新型守护进程></a>新型守护进程</h2><p>Linux 系统上的新型守护进程更容易被监控也更容易实现。<p>守护进程无需实现前文所描述的复杂步骤， 即可直接在 <code>systemd</code> 提供的干净的上下文环境中运行：<p>环境变量已经被清理、信号处理器与信号掩码已经被重置、没有遗留的文件描述符、守护进程自动在其专属的会话中执行、 <code>标准输入(STDIN)</code> 已被连接到 <code>/dev/null 虚拟设备(除非另有配置)</code>、 <code>标准输出(STDOUT)</code> 与<code>标准错误(STDERR)</code> 已被连接到 <code>systemd-journald.service(8) 日志服务(除非另有配置)</code>、<code>umask</code> 已经被重置 … 等等<p>新型守护进程只需要遵守如下要求：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>1. 收到 SIGTERM 信号后 关闭进程并确保干净的退出</span><br><span class=line></span><br><span class=line>2. 收到 SIGHUP 信号后 重新加载配置文件(若需要)</span><br><span class=line></span><br><span class=line>3. 主守护进程在退出时应该按照 LSB recommendations for SysV init scripts[1] 的要求返回恰当的退出码，以便于 systemd 判断服务的退出状态。</span><br><span class=line></span><br><span class=line>4. 若可行，在初始化的最后一步， 通过 D-Bus 创建进程的控制接口， 并在 D-Bus 上注册一个总线名称。</span><br><span class=line></span><br><span class=line>5. 提供一个 .service 单元文件， 包含如何启动/停止/维护该服务的配置。 详见 systemd.service(5) 手册。</span><br><span class=line></span><br><span class=line>6. 尽可能依赖于 systemd 的资源控制与权限剥夺功能 (CPU与内存占用/文件访问等等)， 而不要自己实现它们。 详见 systemd.exec(5) 手册。</span><br><span class=line></span><br><span class=line>7. 若使用了 D-Bus ， 则强烈推荐使用基于 D-Bus 的启动机制。 这样做有许多好处： 守护进程可以按需延迟启动； 可以和依赖于它的进程并行启动(提升启动速度)； 守护进程可以在失败时被自动重启 而不丢失D-Bus总线上的请求(详见下文)</span><br><span class=line></span><br><span class=line>8. 若守护进程通过套接字提供服务， 则强烈推荐使用基于套接字的启动机制(详见下文)。 这样做有许多好处：守护进程可以按需延迟启动； 可以和依赖于它的进程并行启动(提升启动速度)； 对于无状态协议(例如syslog, DNS)， 守护进程可以在失败时被自动重启而不丢失套接字上的请求(详见下文)</span><br><span class=line></span><br><span class=line>9. 若可能，守护进程应该通过 sd_notify(3) 接口通知 systemd "启动已完成"或"状态已更新"这样的消息。</span><br><span class=line></span><br><span class=line>10. 不要使用 syslog() 记录日志， 只需简单的使用 fprintf() 向 STDERR 输出日志即可。 如果必须指明日志等级， 则可以在日志的 行首加上类似 "&LT4>" 这样的前缀即可(这里表示4级"WARNING")。 详见 sd-daemon(3) 与 systemd.exec(5) 手册。</span><br></pre></table></figure><p>上述要求与 Apple MacOS X Daemon Requirements [2] 类似， 但并不完全相同。<h1 id=启动><a class=headerlink href=#启动 title=启动></a>启动</h1><p><code>systemd</code> 提供了多种启动机制 (见下文)， 而服务单元也经常同时使用其中的几种。 例如 <code>bluetoothd.service </code>可以在插入蓝牙硬件时被启动， 也可以在某进程访问其 <code>D-Bus 接口</code>时被启动。 又如打印服务可以在 <code>IPP端口</code>有流量接入时被启动， 也可以在插入打印机硬件时被启动， 还可以在有文件进入打印机 <code>spool</code> 目录时被启动。 甚至对于必须在系统启动时无条件启动的服务， 为了尽可能并发启动， 也应该使用某些启动机制。 如果某守护进程实现了一个 <code>D-Bus</code> 服务或者监听一个套接字， 那么使用基于 <code>D-Bus</code> 或基于<code>套接字</code>的启动机制， 将允许该进程与其客户端同时并行启动 (从而加快启动速度)。 因为所有的通信渠道都已事先建立， 并且不会丢失任何客户端请求，同时 <code>D-Bus 总线</code>或者内核会将客户端请求排入队列等候， 直到完成启动。<h2 id=系统启动时启动><a class=headerlink href=#系统启动时启动 title=系统启动时启动></a>系统启动时启动</h2><p>传统的守护进程一般是在系统启动时通过 <code>SysV</code> 初始化脚本自动启动， <code>systemd </code>也支持这种启动方式。<p>对于 <code>systemd</code> 来说， 如果希望确保某单元在系统启动时自动启动， 那么最佳的做法是在默认启动目标 (通常是 <code>multi-user.target</code> 或 <code>graphical.target</code>) 的 <code>.wants/ </code>目录中为该单元建立软链接。 参见 <code>systemd.unit(5)</code> 手册以了解 <code>.wants/</code> 目录， 参见 <code>systemd.special(7)</code> 手册以了解上述两个特殊的启动目标。<h2 id=基于套接字的启动><a class=headerlink href=#基于套接字的启动 title=基于套接字的启动></a>基于套接字的启动</h2><p>为了尽可能提高并行性与健壮性， 以及简化配置与开发， 对于需要监听套接字的服务， 强烈推荐使用基于套接字的启动机制。 使用此机制后， 守护进程不再需要创建和绑定套接字， 而是由 <code>systemd</code> 接管这个工作。<code>systemd</code> 将会根据单元文件的设置， 预先创建所需的套接字， 并在第一个客户端请求接入的时候启动该服务，以实现服务的按需启动。 该机制的好处还在于， 预先创建好套接字之后， 所有使用此套接字通信的进程可以并行启动 (包括客户端和服务端)。 此外，重启服务只会导致丢失最低限度的客户端连接， 甚至不丢失任何客户端请求 (例如对于 <code>DNS </code>或 <code>syslog</code> 这样的无状态协议)。 因为套接字在服务重启期间始终保持有效并且可被访问， 同时所有客户端请求也都被排入队列等候处理。<p>使用此机制之后， 守护进程必须要从 <code>systemd</code> 接收已创建好的套接字， 而不能自己创建并绑定套接字。 关于如何使用该机制，参见 <code>sd_listen_fds(3)</code> 与 <code>sd-daemon(3)</code> 手册。 只需要小小的修改， 即可在原有启动机制的基础上添加基于套接字的启动机制， 至于如何移植，详见后文。<p><code>systemd</code> 通过 <code>.socket</code> 单元实现该机制，详见 <code>systemd.socket(5) </code>手册。 必须确保所有为支持基于套接字启动而创建的监听 socket 单元都被包含在 <code>sockets.target</code> 中。 建议在 <code>socket</code> 单元的 <code>"[Install]"</code> 小节加入 <code>WantedBy=sockets.target</code> 设置， 以确保在启用该单元时能够自动添加上述依赖关系。 除非明确设置了 <code>DefaultDependencies=no</code> ， 否则会为所有<code> socket</code> 单元隐含的创建必要的顺序依赖。 有关 <code>sockets.target</code> 的解释，详见<code> systemd.special(7)</code> 手册。 如果某 <code>socket</code> 单元已被包含在 <code>sockets.target</code> 中， 那么不建议在其中再添加任何额外的依赖关系 (例如 <code>multi-user.target</code> 之类)。<h2 id=基于-D-Bus-的启动><a title="基于 D-Bus 的启动" class=headerlink href=#基于-D-Bus-的启动></a>基于 <code>D-Bus</code> 的启动</h2><p>如果守护进程使用 <code>D-Bus</code> 与客户端通信， 那么它应该使用基于 <code>D-Bus</code> 的启动机制， 这样当客户端访问其 <code>D-Bus</code> 接口时， 该服务将被自动启动。 该机制是通过 <code>D-Bus service</code> 文件实现的 (不要与普通的单元文件混淆)。 为了确保让 <code>D-Bus</code> 使用 <code>systemd</code> 来启动与维护守护进程， 必须在这些 <code>D-Bus service</code> 文件中使用 <code>SystemdService=指明其匹配的服务单元</code>。 例如，对于文件名为 <code>org.freedesktop.RealtimeKit.service</code> 的 <code>D-Bus service</code> 来说， 为了将其绑定到 <code>rtkit-daemon.service</code> 服务单元， 必须确保在该文件中设置了 <code>SystemdService=rtkit-daemon.service</code> 指令。 注意，必须明确设置 <code>SystemdService=</code> 指令， 否则当服务单元<br>同时使用多种启动机制时， 可能会导致竞争条件的出现。<h2 id=基于设备的启动><a class=headerlink href=#基于设备的启动 title=基于设备的启动></a>基于设备的启动</h2><p>用于管理特定类型硬件的守护进程， 只应该在符合条件的硬件变为可用或者被插入时，才需要启动。 为了达到上述目的， 可以将服务的启动 / 停止与硬件的插入 / 拔出事件绑定。 当带有 <code>"systemd"</code> 标签的设备出现在 <code>sysfs/udev</code> 设备树中时， <code>systemd</code> 将会自动为其创建对应的 <code>device</code> 单元。 通过向这些单元中添加对其他单元的 <code>Wants= 依赖</code>， 就可以实现当该 <code>device</code> 单元被启动 (也就是硬件被插入) 时， 连带启动其他单元，从而实现基于设备的启动。 这可以通过向 <code>udev</code> 规则库中添加 <code>SYSTEMD_WANTS= 属性来实现</code>， 详见 <code>systemd.device(5)</code> 手册。 通常，并不是将 <code>service</code> 单元直接添加到设备的 <code>Wants=</code> 依赖中， 而是通过专用的<code> target</code> 单元间接添加。 例如，不是将 <code>bluetoothd.service</code> 添加到各种蓝牙设备的 <code>Wants=</code> 依赖中， 而是将 <code>bluetoothd.service</code> 添加到 <code>bluetooth.target</code> 的 <code>Wants=</code> 依赖中， 同时再将 <code> bluetooth.target</code> 添加到各种蓝牙设备的 <code>Wants=</code> 依赖中。 通过引入 <code>bluetooth.target</code> 这个抽象层， 系统管理员无需批量修改 <code>udev</code> 规则库， 仅通过 <code>systemctl enable|disable ...</code> 命令 修改 <code>bluetooth.target.wants/</code> 目录中的软链接， 即可控制 <code>bluetoothd.service</code> 的使用。<h2 id=基于路径的启动><a class=headerlink href=#基于路径的启动 title=基于路径的启动></a>基于路径的启动</h2><p>对于处理 <code>spool</code> 文件或目录的守护进程 (例如打印服务) 来说， 仅在 <code>spool</code> 文件或目录状态发生变化或者内容非空时， 才需要启动。 通过 <code>.path</code> 单元实现的、 基于路径的启动机制正好适用于这种场合， 详见 <code>systemd.path(5)</code> 手册。<h2 id=基于定时器的启动><a class=headerlink href=#基于定时器的启动 title=基于定时器的启动></a>基于定时器的启动</h2><p>对于周期性的操作 (例如垃圾文件清理或者网络对时)， 可以通过基于定时器的启动机制来实现。 这种机制通过.timer 单元实现，详见 <code>systemd.timer(5)</code> 手册。<h2 id=其他启动方式><a class=headerlink href=#其他启动方式 title=其他启动方式></a>其他启动方式</h2><p>在其他操作系统上还存在着其他的启动机制， 不过这些机制都可以被前述的各种机制的组合替代。 因此在这里不再赘述。<h1 id=与-SYSTEMD-整合><a title="与 SYSTEMD 整合" class=headerlink href=#与-SYSTEMD-整合></a>与 SYSTEMD 整合</h1><h2 id=编写-systemd-单元文件><a title="编写 systemd 单元文件" class=headerlink href=#编写-systemd-单元文件></a>编写 <code>systemd</code> 单元文件</h2><p>在编写单元文件时应当考虑下列建议：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>1. 尽可能不用 Type=forking 。 若非用不可，则必须正确设置 PIDFile= 指令。参见 systemd.service(5) 手册。</span><br><span class=line></span><br><span class=line>2. 若守护进程在 D-Bus 上注册了一个名字， 则应尽可能使用 Type=dbus</span><br><span class=line></span><br><span class=line>3. 设置一个易于理解的 Description=</span><br><span class=line></span><br><span class=line>4. 确保 DefaultDependencies=yes ， 除非该单元必须在系统启动的早期启动或者必须在系统关闭的末期关闭。</span><br><span class=line></span><br><span class=line>5. 通常无需显式定义依赖关系。 不过，如果确实需要显式定义依赖关系， 为了确保单元文件不局限于特定的发行版，仅应该依赖于 systemd.special(7) 中列出的单元以及自身所属软件包中提供的单元。</span><br><span class=line></span><br><span class=line>6. 确保在 "[Install]" 小节中包含完整的启用信息(参见 systemd.unit(5) 手册)。 若希望自动启动该单元，则应该设置 WantedBy=multi-user.target 或 WantedBy=graphical.target 若希望自动启动该单元的套接字，则应该设置 WantedBy=sockets.target 。 通常你还希望在启用该单元时， 一起启用对应的套接字单元(假定为 foo.service)， 因此还应该设置 Also=foo.socket</span><br></pre></table></figure><h2 id=安装-service-单元文件><a title="安装 service 单元文件" class=headerlink href=#安装-service-单元文件></a>安装 <code>service</code> 单元文件</h2><p>当从源代码编译安装 ( <code>make install</code> ) 软件包时， 其中的系统服务单元文件会被默认安装到 <code>pkg-config systemd --variable=systemdsystemunitdir</code> 命令返回的目录中 (通常是 <code>/usr/lib/systemd/system</code> )； 而其中的用户服务单元文件会被默认安装到 <code>pkg-config systemd --variable=systemduserunitdir</code> 命令返回的目录中 (通是 <code>/usr/lib/systemd/user</code> )； 但并不应该使用 <code>systemctl enable ...</code> 命令启用它们。 当从包管理器安装 ( <code>rpm -i</code> ) 二进制软件包时， 其中的单元文件应该同样安装到上述位置。 但不同之处在于， 还应该使用 <code>systemctl enable ... </code> 命令启用它们， 因此安装的单元有可能会在开机时自动启动。<h1 id=移植已有的守护进程><a class=headerlink href=#移植已有的守护进程 title=移植已有的守护进程></a>移植已有的守护进程</h1><p>虽然 <code>systemd</code> 兼容传统的 <code>SysV</code> 初始化系统， 但是移植旧有的守护进程可以更好的利用 <code>systemd</code> 的先进特性。建议对旧有的 <code>SysV</code> 守护进程做如下改进： …[省略]…<h1 id=放置守护进程的数据><a class=headerlink href=#放置守护进程的数据 title=放置守护进程的数据></a>放置守护进程的数据</h1><p>建议遵守 <code>file-hierarchy(7)</code> 所建议的通用准则。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/myphoto.png itemprop=image> <meta content="Chen Chao" itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="More haste, less speed." itemprop=name> <meta content="Live, Work, Sports" itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | More haste, less speed." itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/ itemprop=url>TCP 和 UDP 通信</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-02-23 17:01:54 / 修改时间：18:33:58" datetime=2023-02-23T17:01:54+08:00>2023-02-23</time> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>3k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>11 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><p>介绍了 TCP 和 UDP 的通信方法<!--noindex--><div class=post-button><a class=btn href=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/#more rel=contents> 阅读全文 » </a></div><!--/noindex--></div><footer class=post-footer><div class=post-eof></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2023</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Chen Chao</span></div><div class=wordcount><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-chart-line"></i> </span> <span title=站点总字数>7k</span> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span> <span title=站点阅读时长>24 分钟</span> </span></div><div class=powered-by>由 <a href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a href=https://theme-next.js.org/ rel=noopener target=_blank>NexT.Gemini</a> 强力驱动</div><script defer src=/lib/three.js></script></div></footer><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/next-boot.js></script><script class=next-config data-name=pdf type=application/json>{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src=/js/third-party/tags/pdf.js></script><script src=/js/third-party/pace.js></script><script class=next-config data-name=exif type=application/json>"{FocalLength}mm f/{FNumber} {ExposureTime}s"</script><script src=https://fastly.jsdelivr.net/npm/exif-js@2/exif.min.js></script><script src=/lib/exif.js></script>