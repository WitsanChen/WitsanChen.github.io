<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity=sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU= rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-big-counter.css rel=stylesheet><script crossorigin=anonymous integrity=sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0= src=https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js></script><script class=next-config data-name=main type=application/json>{"hostname":"witsanchen.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src=/js/config.js></script><meta content="介绍了 TCP 和 UDP 的通信方法" name=description><meta content=article property=og:type><meta content="TCP 和 UDP 通信" property=og:title><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/index.html property=og:url><meta content="More haste, less speed." property=og:site_name><meta content="介绍了 TCP 和 UDP 的通信方法" property=og:description><meta content=zh_CN property=og:locale><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/1677032656094.png property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222102619312.png property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222102659154.png property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222111345907.png property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222111330936.png property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/112P63295-0.jpg property=og:image><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/112PA615-1.jpg property=og:image><meta content=2023-02-23T09:01:54.000Z property=article:published_time><meta content=2023-02-23T10:33:58.027Z property=article:modified_time><meta content="Chen Chao" property=article:author><meta content=WebRTC property=article:tag><meta content=summary name=twitter:card><meta content=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/1677032656094.png name=twitter:image><link href=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/","path":"2023/02/23/TCP和UDP通信/","title":"TCP 和 UDP 通信"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>TCP 和 UDP 通信 | More haste, less speed.</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>More haste, less speed.</p> <i class=logo-line></i> </a></div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>2</span></a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>1</span></a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>2</span></a><li class="menu-item menu-item-schedule"><a href=/schedule/ rel=section><i class="fa fa-calendar fa-fw"></i>日程表</a></ul></nav></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#socket-%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97><span class=nav-number>1.</span> <span class=nav-text>socket ( ): 创建套接字</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#bind-%E5%92%8C-connect-%E7%BB%91%E5%AE%9A%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B9%B6%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A5><span class=nav-number>2.</span> <span class=nav-text>bind() 和 connect(): 绑定套接字并建立链接</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#bind-%E5%87%BD%E6%95%B0><span class=nav-number>2.1.</span> <span class=nav-text>bind () 函数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#sockaddr-in-%E7%BB%93%E6%9E%84%E4%BD%93><span class=nav-number>2.1.0.1.</span> <span class=nav-text>sockaddr_in 结构体</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#in-addr-%E7%BB%93%E6%9E%84%E4%BD%93><span class=nav-number>2.1.0.2.</span> <span class=nav-text>in_addr 结构体</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-sockaddr-in-%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8-sockaddr><span class=nav-number>2.1.0.3.</span> <span class=nav-text>为什么使用 sockaddr_in 而不使用 sockaddr</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#connect-%E5%87%BD%E6%95%B0><span class=nav-number>2.2.</span> <span class=nav-text>connect () 函数</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#listen-%E5%92%8Caccept-%EF%BC%9A%E8%AE%A9%E5%A5%97%E6%8E%A5%E5%AD%97%E8%BF%9B%E5%85%A5%E7%9B%91%E5%90%AC%E7%8A%B6%E6%80%81%E5%B9%B6%E5%93%8D%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82><span class=nav-number>3.</span> <span class=nav-text>listen () 和 accept ()：让套接字进入监听状态并响应客户端请求</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#listen-%E5%87%BD%E6%95%B0><span class=nav-number>3.1.</span> <span class=nav-text>listen () 函数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97><span class=nav-number>3.1.1.</span> <span class=nav-text>请求队列</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#accept-%E5%87%BD%E6%95%B0><span class=nav-number>3.2.</span> <span class=nav-text>accept () 函数</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#send-x2F-recv-%E5%92%8Cwrite-x2F-read-%EF%BC%9A%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE><span class=nav-number>4.</span> <span class=nav-text>send ()/recv () 和 write ()/read ()：发送数据和接收数据</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Linux%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81><span class=nav-number>4.1.</span> <span class=nav-text>Linux 下数据的接收和发送</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt="Chen Chao" class=site-author-image itemprop=image src=/images/myphoto.png><p class=site-author-name itemprop=name>Chen Chao<div class=site-description itemprop=description>Live, Work, Sports</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>2</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><span class=site-state-item-count>1</span><span class=site-state-item-name>分类</span></div><div class="site-state-item site-state-tags"><span class=site-state-item-count>2</span><span class=site-state-item-name>标签</span></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://witsanchen.github.io/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/myphoto.png itemprop=image> <meta content="Chen Chao" itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="More haste, less speed." itemprop=name> <meta content="Live, Work, Sports" itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="TCP 和 UDP 通信 | More haste, less speed." itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>TCP 和 UDP 通信</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-02-23 17:01:54 / 修改时间：18:33:58" datetime=2023-02-23T17:01:54+08:00>2023-02-23</time> </span><span class=post-meta-break></span><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>3k</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>11 分钟</span> </span></div></div></header><div class=post-body itemprop=articleBody><p>介绍了 TCP 和 UDP 的通信方法</p><span id=more></span><p><img alt=1677032656094 src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/1677032656094.png><p><img alt=image-20230222102619312 src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222102619312.png><p><img alt=image-20230222102659154 src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222102659154.png><p><img alt=image-20230222111345907 src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222111345907.png><p><img alt=image-20230222111330936 src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/image-20230222111330936.png><h1 id=socket-创建套接字><a title="socket( ): 创建套接字" class=headerlink href=#socket-创建套接字></a>socket ( ): 创建套接字</h1><p>Linux 中的一切都是文件，使用 socket () 函数创建套接字以后，返回值就是一个 int 类型的文件描述符。<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>int socket(int af, int type, int protocol);</span><br></pre></table></figure><p><strong>地址族（Address Family）af</strong><blockquote><ul><li><p>地址族也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。</p><li><p>AF 是 “Address Family” 的简写，INET 是 “Inetnet” 的简写。</p><li><p>AF_INET 表示 IPv4 地址，例如 127.0.0.1；</p><li><p>AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</p><li><p><code>127.0.0.1</code> 是一个特殊 IP 地址，表示本机地址，后面的教程会经常用到。</p><li><p>也可以使用 PF 前缀，PF 是 “Protocol Family” 的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</p></ul></blockquote><p><strong>数据传输方式 / 套接字类型 type</strong><blockquote><p>常用的有 SOCK_STREAM（流格式套接字 / 面向连接的套接字） 和 SOCK_DGRAM（数据报套接字 / 无连接的套接字）。</blockquote><p><strong>传输协议 protocol</strong><blockquote><p>常用的有 <code>IPPROTO_TCP</code> 和 <code>IPPTOTO_UDP</code>，分别表示 <code>TCP 传输协议</code> 和 <code>UDP 传输协议</code>。<p>一般情况下有了 <code>af</code> 和 <code>type</code> 两个参数就可以创建套接字了，操作系统会自动推演出协议类型。除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</blockquote><p>本教程使用 <code>IPv4</code> 地址，参数 <code>af</code> 的值为 <code>PF_INET</code>。如果使用 <code>SOCK_STREAM</code> 传输数据，那么满足这两个条件的协议只有 <code>TCP</code>，因此可以这样来调用 <code>socket()</code> 函数：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  //IPPROTO_TCP表示TCP协议</span><br></pre></table></figure><p>这种套接字称为 TCP 套接字。<p>如果使用 <code>SOCK_DGRAM</code> 传输方式，那么满足这两个条件的协议只有 <code>UDP</code>，因此可以这样来调用 <code>socket()</code> 函数：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  //IPPROTO_UDP表示UDP协议</span><br></pre></table></figure><p>这种套接字称为 <code>UDP</code> 套接字。<p>上面两种情况都只有一种协议满足条件，可以将 <code>protocol</code> 的值设为 <code>0</code>，系统会自动推演出应该使用什么协议，如下所示：<figure class="highlight plaintext"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>int tcp_socket = socket(AF_INET, SOCK_STREAM, 0);  //创建TCP套接字</span><br><span class=line>int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);  //创建UDP套接字</span><br></pre></table></figure><p>后面的教程中多采用这种简化写法。<h1 id=bind-和-connect-绑定套接字并建立链接><a title="bind() 和 connect(): 绑定套接字并建立链接" class=headerlink href=#bind-和-connect-绑定套接字并建立链接></a><code>bind()</code> 和 <code>connect()</code>: 绑定套接字并建立链接</h1><p><code>socket()</code> 函数用来创建套接字，确定套接字的各种属性，然后<strong>服务器端要用 <code>bind()</code> 函数</strong>将<code>套接字</code>与特定的 <code>IP 地址</code>和<code>端口</code>绑定起来。只有这样，流经该 <code>IP 地址</code> 和 <code>端口</code> 的数据才能交给 <code>套接字</code> 处理。类似地，<strong>客户端也要用 <code>connect()</code> 函数</strong>建立连接。<h2 id=bind-函数><a title="bind() 函数" class=headerlink href=#bind-函数></a>bind () 函数</h2><p><code>bind()</code> 函数的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>int</span> <span class=title>bind</span><span class=params>(<span class=type>int</span> sock, <span class=keyword>struct</span> sockaddr *addr, <span class=type>socklen_t</span> addrlen)</span></span>;  <span class=comment>//Linux</span></span><br></pre></table></figure><p><code>sock</code> 为 <code>socket</code> 文件描述符，<code>addr</code> 为 <code>sockaddr</code> 结构体变量的指针，<code>addrlen</code> 为 <code>addr</code> 变量的大小，可由 <code>sizeof()</code> 计算得出。<p>下面的代码，将创建的套接字与 IP 地址 127.0.0.1、端口 1234 绑定：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>//创建套接字</span></span><br><span class=line><span class=type>int</span> serv_sock = <span class=built_in>socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class=line></span><br><span class=line><span class=comment>//创建sockaddr_in结构体变量</span></span><br><span class=line><span class=keyword>struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class=line><span class=built_in>memset</span>(&serv_addr, <span class=number>0</span>, <span class=built_in>sizeof</span>(serv_addr));  <span class=comment>//每个字节都用0填充</span></span><br><span class=line>serv_addr.sin_family = AF_INET;  <span class=comment>//使用IPv4地址</span></span><br><span class=line>serv_addr.sin_addr.s_addr = <span class=built_in>inet_addr</span>(<span class=string>"127.0.0.1"</span>);  <span class=comment>//具体的IP地址</span></span><br><span class=line>serv_addr.sin_port = <span class=built_in>htons</span>(<span class=number>1234</span>);  <span class=comment>//端口</span></span><br><span class=line></span><br><span class=line><span class=comment>//将套接字和IP、端口绑定</span></span><br><span class=line><span class=built_in>bind</span>(serv_sock, (<span class=keyword>struct</span> sockaddr*)&serv_addr, <span class=built_in>sizeof</span>(serv_addr));</span><br></pre></table></figure><p>这里我们使用 sockaddr_in 结构体，然后再强制转换为 sockaddr 类型，后边会讲解为什么这样做。<h4 id=sockaddr-in-结构体><a title="sockaddr_in 结构体" class=headerlink href=#sockaddr-in-结构体></a>sockaddr_in 结构体</h4><p>接下来不妨先看一下 sockaddr_in 结构体，它的成员变量如下：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">sockaddr_in</span>{</span><br><span class=line>    <span class=type>sa_family_t</span>     sin_family;   <span class=comment>//地址族（Address Family），也就是地址类型</span></span><br><span class=line>    <span class=type>uint16_t</span>        sin_port;     <span class=comment>//16位的端口号</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">in_addr</span>  sin_addr;     <span class=comment>//32位IP地址</span></span><br><span class=line>    <span class=type>char</span>            sin_zero[<span class=number>8</span>];  <span class=comment>//不使用，一般用0填充</span></span><br><span class=line>};</span><br></pre></table></figure><blockquote><ul><li><p><code>sin_family</code> 和 <code>socket()</code> 的第一个参数的含义相同，取值也要保持一致。</p><li><p><code>sin_prot</code> 为端口号。uint16_t 的长度为<strong>两个字节</strong>，理论上端口号的取值范围为 <code>0~65536</code>，但 <code>0~1023</code> 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 <code>1024~65536</code> 之间分配端口号。</p><li><p>端口号需要用 <code>htons()</code> 函数转换，后面会讲解为什么。</p><li><p><code>sin_addr</code> 是 <code>struct in_addr</code> 结构体类型的变量，下面会详细讲解。</p><li><p><code>sin_zero[8]</code> 是多余的 <code>8</code> 个字节，没有用，一般使用 <code>memset()</code> 函数填充为 <code>0</code>。上面的代码中，先用 <code>memset()</code> 将结构体的全部字节填充为 <code>0</code>，再给前 <code>3</code> 个成员赋值，剩下的 <code>sin_zero</code> 自然就是 <code>0</code> 了。</p></ul></blockquote><h4 id=in-addr-结构体><a title="in_addr 结构体" class=headerlink href=#in-addr-结构体></a>in_addr 结构体</h4><p>sockaddr_in 的第 3 个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">in_addr</span>{</span><br><span class=line>    <span class=type>in_addr_t</span>  s_addr;  <span class=comment>//32位的IP地址</span></span><br><span class=line>};</span><br></pre></table></figure><p><code>in_addr_t</code> 在头文件 <code>&LTnetinet/in.h></code> 中定义，等价于 <code>unsigned long</code>，长度为 4 个字节。也就是说，<code>s_addr</code> 是一个整数，而 <code>IP</code> 地址是一个字符串，所以需要 <code>inet_addr()</code> 函数进行转换，例如：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>unsigned</span> <span class=type>long</span> ip = <span class=built_in>inet_addr</span>(<span class=string>"127.0.0.1"</span>);<span class=comment>//将点分十进制IP转换成网络字节序IP</span></span><br><span class=line><span class=built_in>printf</span>(<span class=string>"%ld\n"</span>, ip);</span><br></pre></table></figure><p>运行结果：<br>16777343<p><img alt="图解 sockaddr_in 结构体" src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/112P63295-0.jpg><p>为什么要搞这么复杂，结构体中嵌套结构体，而不用 sockaddr_in 的一个成员变量来指明 IP 地址呢？socket () 函数的第一个参数已经指明了地址类型，为什么在 sockaddr_in 结构体中还要再说明一次呢，这不是啰嗦吗？<p>这些繁琐的细节确实给初学者带来了一定的障碍，我想，这或许是历史原因吧，后面的接口总要兼容前面的代码。各位读者一定要有耐心，暂时不理解没有关系，根据教程中的代码 “照猫画虎” 即可，时间久了自然会接受。<h4 id=为什么使用-sockaddr-in-而不使用-sockaddr><a title="为什么使用 sockaddr_in 而不使用 sockaddr" class=headerlink href=#为什么使用-sockaddr-in-而不使用-sockaddr></a>为什么使用 sockaddr_in 而不使用 sockaddr</h4><p><code>bind()</code> 第二个参数的类型为 <code>sockaddr</code>，而代码中却使用 <code>sockaddr_in</code>，然后再强制转换为 <code>sockaddr</code>，这是为什么呢？<p>sockaddr 结构体的定义如下：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">sockaddr</span>{</span><br><span class=line>    <span class=type>sa_family_t</span>  sin_family;   <span class=comment>//地址族（Address Family），也就是地址类型</span></span><br><span class=line>    <span class=type>char</span>         sa_data[<span class=number>14</span>];  <span class=comment>//IP地址和端口号</span></span><br><span class=line>};</span><br></pre></table></figure><p>下图是 <code>sockaddr</code> 与 <code>sockaddr_in</code> 的对比（括号中的数字表示所占用的字节数）：<p><img alt=img src=/2023/02/23/TCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1/112PA615-1.jpg><p><strong><code>sockaddr</code> 和 <code>sockaddr_in</code> 的长度相同，都是 16 字节</strong>，只是将 IP 地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明 IP 地址和端口号，例如”127.0.0.1:80“，遗憾的是，没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。<p>可以认为，sockaddr 是一种通用的结构体，可以用来保存多种类型的 IP 地址和端口号，而 sockaddr_in 是专门用来保存 IPv4 地址的结构体。另外还有 sockaddr_in6，用来保存 IPv6 地址，它的定义如下：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>struct</span> <span class="title class_">sockaddr_in6</span> {</span><br><span class=line>    <span class=type>sa_family_t</span> sin6_family;  <span class=comment>//(2)地址类型，取值为AF_INET6</span></span><br><span class=line>    <span class=type>in_port_t</span> sin6_port;  <span class=comment>//(2)16位端口号</span></span><br><span class=line>    <span class=type>uint32_t</span> sin6_flowinfo;  <span class=comment>//(4)IPv6流信息</span></span><br><span class=line>    <span class=keyword>struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class=comment>//(4)具体的IPv6地址</span></span><br><span class=line>    <span class=type>uint32_t</span> sin6_scope_id;  <span class=comment>//(4)接口范围ID</span></span><br><span class=line>};</span><br></pre></table></figure><p>正是由于通用结构体 sockaddr 使用不便，才针对不同的地址类型定义了不同的结构体。<h2 id=connect-函数><a title="connect() 函数" class=headerlink href=#connect-函数></a>connect () 函数</h2><p><code>connect()</code> 函数用来建立连接，它的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>int</span> <span class=title>connect</span><span class=params>(<span class=type>int</span> sock, <span class=keyword>struct</span> sockaddr *serv_addr, <span class=type>socklen_t</span> addrlen)</span></span>;  <span class=comment>//Linux</span></span><br></pre></table></figure><p>各个参数的说明和 bind () 相同，不再赘述。<h1 id=listen-和accept-：让套接字进入监听状态并响应客户端请求><a class=headerlink href=#listen-和accept-：让套接字进入监听状态并响应客户端请求 title=listen()和accept()：让套接字进入监听状态并响应客户端请求></a>listen () 和 accept ()：让套接字进入监听状态并响应客户端请求</h1><p>对于服务器端程序，使用 <code>bind()</code> 绑定套接字后，还需要使用 <code>listen()</code> 函数让套接字进入被动监听状态，再调用 <code>accept()</code> 函数，就可以随时响应客户端的请求了。<h2 id=listen-函数><a title="listen() 函数" class=headerlink href=#listen-函数></a>listen () 函数</h2><p>通过 <code>listen()</code> 函数可以让套接字进入<strong>被动监听</strong>状态，它的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>int</span> <span class=title>listen</span><span class=params>(<span class=type>int</span> sock, <span class=type>int</span> backlog)</span></span>;  <span class=comment>//Linuxint </span></span><br></pre></table></figure><p><code>sock</code> 为需要进入监听状态的套接字，<code>backlog</code> 为<strong>请求队列</strong>的最大长度。<p>所谓<strong>被动监听</strong>，是指当没有客户端请求时，套接字处于 “睡眠” 状态，只有当接收到客户端请求时，套接字才会被 “唤醒” 来响应请求。<h3 id=请求队列><a class=headerlink href=#请求队列 title=请求队列></a>请求队列</h3><p>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为 <code>请求队列（Request Queue）</code>。<p>缓冲区的长度（能存放多少个客户端请求）可以通过 <code>listen()</code> 函数的 <code>backlog</code> 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是 10 或者 20。<p>如果将 <code>backlog</code> 的值设置为 <code>SOMAXCONN</code>，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。<p>当请求队列满时，就不再接收新的请求，对于 <code>Linux</code>，客户端会收到 <code>ECONNREFUSED</code> 错误。<p>注意：<code>listen()</code> 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 <code>accept()</code> 函数。<h2 id=accept-函数><a title="accept() 函数" class=headerlink href=#accept-函数></a>accept () 函数</h2><p>当套接字处于监听状态时，可以通过 <code>accept()</code> 函数<strong>来接收客户端请求</strong>。它的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>int</span> <span class=title>accept</span><span class=params>(<span class=type>int</span> sock, <span class=keyword>struct</span> sockaddr *addr, <span class=type>socklen_t</span> *addrlen)</span></span>;  <span class=comment>//LinuxSOCKET</span></span><br></pre></table></figure><p>它的参数与 <code>listen()</code> 和 <code>connect()</code> 是相同的：<code>sock</code> 为服务器端套接字，<code>addr</code> 为 <code>sockaddr_in</code> 结构体变量，<code>addrlen</code> 为参数 <code>addr</code> 的长度，可由 <code>sizeof()</code> 求得。<p><code>accept()</code> 返回一个新的套接字来和客户端通信，<code>addr</code> 保存了客户端的 <code>IP地址</code> 和 <code>端口号</code> ，而 <code>sock</code> 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。<p>最后需要说明的是：<code>listen()</code> 只是让套接字进入监听状态，并没有真正接收客户端请求，<code>listen()</code> 后面的代码会继续执行，直到遇到 <code>accept()</code> 。<code>accept()</code> 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。<h1 id=send-x2F-recv-和write-x2F-read-：发送数据和接收数据><a class=headerlink href=#send-x2F-recv-和write-x2F-read-：发送数据和接收数据 title=send()/recv()和write()/read()：发送数据和接收数据></a>send ()/recv () 和 write ()/read ()：发送数据和接收数据</h1><p>在 Linux 平台下，使用不同的函数发送和接收 <code>socket</code> 数据，下面我们分别讲解。<h2 id=Linux下数据的接收和发送><a class=headerlink href=#Linux下数据的接收和发送 title=Linux下数据的接收和发送></a>Linux 下数据的接收和发送</h2><p>Linux 不区分套接字文件和普通文件，使用 <code>write()</code> 可以向套接字中写入数据，使用 <code>read()</code> 可以从套接字中读取数据。<p>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 <code>write()</code> 向套接字写入数据，客户端就能收到，然后再使用 <code>read()</code> 从套接字中读取出来，就完成了一次通信。<p><code>write()</code> 的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>ssize_t</span> <span class=title>write</span><span class=params>(<span class=type>int</span> fd, <span class=type>const</span> <span class=type>void</span> *buf, <span class=type>size_t</span> nbytes)</span></span>;</span><br></pre></table></figure><p><code>fd</code> 为要写入的文件的描述符，<code>buf</code> 为要写入的数据的缓冲区地址，<code>nbytes</code> 为要写入的数据的字节数。<blockquote><p>size_t 是通过 typedef 声明的 unsigned int 类型；ssize_t 在 “size_t” 前面加了一个”s”，代表 signed，即 ssize_t 是通过 typedef 声明的 signed int 类型。</blockquote><p><code>write()</code> 函数会将缓冲区 <code>buf</code> 中的 <code>nbytes</code> 个字节写入文件 <code>fd</code>，成功则返回写入的字节数，失败则返回 <code>-1</code>。<p><code>read()</code> 的原型为：<figure class="highlight cpp"><table><tbody><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>ssize_t</span> <span class=title>read</span><span class=params>(<span class=type>int</span> fd, <span class=type>void</span> *buf, <span class=type>size_t</span> nbytes)</span></span>;</span><br></pre></table></figure><p><code>fd</code> 为要读取的文件的描述符，<code>buf</code> 为要接收数据的缓冲区地址，<code>nbytes</code> 为要读取的数据的字节数。<p><code>read()</code> 函数会从 <code>fd</code> 文件中读取 <code>nbytes</code> 个字节并保存到缓冲区 <code>buf</code>，成功则返回读取到的字节数（但遇到文件结尾则返回 0），失败则返回 -1。</div><footer class=post-footer><div class=post-tags><a href=/tags/WebRTC/ rel=tag># WebRTC</a></div><div class=post-nav><div class=post-nav-item></div><div class=post-nav-item><a href=/2023/02/23/daemon/ rel=next title=daemon> daemon <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2023</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Chen Chao</span></div><div class=wordcount><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-chart-line"></i> </span> <span title=站点总字数>7k</span> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span> <span title=站点阅读时长>24 分钟</span> </span></div><div class=powered-by>由 <a href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a href=https://theme-next.js.org/ rel=noopener target=_blank>NexT.Gemini</a> 强力驱动</div><script defer src=/lib/three.js></script></div></footer><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/next-boot.js></script><script class=next-config data-name=pdf type=application/json>{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script><script src=/js/third-party/tags/pdf.js></script><script src=/js/third-party/pace.js></script><script class=next-config data-name=exif type=application/json>"{FocalLength}mm f/{FNumber} {ExposureTime}s"</script><script src=https://fastly.jsdelivr.net/npm/exif-js@2/exif.min.js></script><script src=/lib/exif.js></script>